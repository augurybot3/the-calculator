<!----> DOM Document Object Model-->
<html>
<div id="container">
    <div class="display"></div>
    <div class="controls"></div>
</div>

<!-- css selectors of div class display-->
<style>
    div.display .display #container>.display div#container>div.display
</style>

/* using relational selectors in javascript */

<script>
    const container = document.querySelector('container');
    console.dir(container.firstElementChild);
    const controls = document.querySelector('.controls');
    console.dir(controls.previousElementSibling); /*selects the prior sibling => .display */

    /* DOM METHODS */

    /* Query Selectors */

    element.querySelector(selector) /*returns a reference to the first match of selector */
    element.querySelectorAll(selectors) /* returns a nodelist containing references to all matches of selectors 

    when using querySelectorAll the return value is NOT an array. It looks like an array but is really a nodlist.
    you can convert a nodelist to an array. */

    Array.from() /* or by use of the spread operator */ (...) 
    
    /* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax */

        /* SPREAD OPERATOR SYNTAX 
        THE 3 types of acceptable spread syntax */

    /* function arguments */ (myFunction(a, ...iterableObj, b)) 
    /* array literals */ ([1, ...iterableObj, '4', 'five', 6]) 
    /* object literals */ ({ ...obj, key: 'value' }) 

    /* TO COPY AN ARRAY LITERAL */

    const arr = [1, 2, 3];
    xonst arr2 = [...arr]; /* like arr.slice() */

    arr2.push(4);
/*  arr2 becomes [1, 2, 3, 4] */
/*  arr remains unaffected */

    /* A BETTER WAY TO CONCATENATE ARRAYS 
    instead of this: */
    
    let arr1 = [0, 1, 2];
    const arr2 = [3, 4, 5];

    arr1 = arr1.concat(arr2);
    /* arr1 is now [0, 1, 2, 3, 4, 5] */

    /* use spread syntax like so: */
    
    arr1 = [...arr1, ...arr2];
    /* arr1 is now [0, 1, 2, 3, 4, 5] */





    /* Element Creation */

    const div = document.createElement(tagName, [options]);
    /*creates a new element of tag type tag name. [options] are additional parameters 
    
    EXAMPLE:*/
    const div = document.createElement('div');

    /* You can place the element into the DOM with one of the following methods:

     APPEND ELEMENTS */

    /* parentNode.appendChild(childNode) /* appends childNode as the last child of parentNode
    parentNode.insertBefore(newNode, referenceNode) /* inserts newNode into parentNode before referenceNode

    REMOVE ELEMENTS */

    parentNode.removeChild(child) /* removes child from parentNode on the DOM and returns a reference to child

    ALTERING ELEMENTS */

    const div = document.createElement('div'); /* creates a new div referenced in the variable 'div'

    ADDING INLINE STYLE */

    div.style.color = 'blue'; /* adds the indicated style rule */
    div.style.cssText = 'color: blue; background: white;'; /* adds several style rules */container
    div.setAttributes('style', 'color: blue; background: white;'); /* adds several style rules */

    /* see DOM Enlightenment's http://domenlightenment.com/#6.2 for more info inline styles
    Note that if you’re accessing a kebab-cased CSS rule from JS, you’ll either need to use camelCase or 
    you’ll need to use bracket notation instead of dot notation.*/

    div.style.background - color /* doesn't work - attempts to subtract color from div.style.background */
    div.style.backgroundColor /* access the div's background-color style */
    div.style['background-color'] /* also works */
    div.style.cssText = "background-color: white;" /* ok in a string

    EDITING ATTRIBUTES */

    div.setAttribute('id', 'theDiv'); /* if id exists, update it to 'theDiv', else create an id with value "theDiv"; */
    div.getAttributes('id'); /* returns value of specified attribute, in this case "theDiv"; */
    div.removeAttribute('id'); /* removes specified attribute

    see MDN's section on HTML Attributes https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes for more info on available attributes 

    WORKING WITH CLASSES */

    div.classList.add('new'); /* adds class "new" to your new div */
    div.classList.remove('new'); /* removes "new" class from div */
    div.classList.toggle('active'); /* if div doesn't have class "active" then add it, or if it does, then remove it

    it is often standard (and cleaner) to toggle a CSS style rather than adding and removing inline CSS

    ADDING TEXT CONTENT */

    div.textContent = 'Hello World!' /* creates a text node containing "Hello World!" and inserts it in div

    ADDING HTML CONTENT */

    div.innerHTML = '<span>Hello World!</span>'; /* renders the HTML inside div */
    
    /*    note that textContent is preferable for adding text, and innerHTML should be used sparingly as it can create security risks if misused. 
    Check out the video https://www.youtube.com/watch?v=ns1LX6mEvyM if you want to see an example of how. */

    /* your HTML file */
        <body>
            <h1>
                THE TITLE OF YOUR WEBPAGE
                </h1>
                <div id="container"></div>
                </body>
   
                
                
    /* your javaScript file */

    const container = document.querySelector('container');

    const content = document.createElement('div');
    content.classList.add('content');
    content.textContent = 'This is the glorious text-content!';

    container.appendChild(content);

    /* in the javaScript file, first we get a reference to the container div that already
    exists in our HTML. Then we create a new div and store it in the variable
    content. We add a class and some text to the content div and finally append
    that div to container. All in all it's a simple process. After the javaScript code js
    run, our DOM tree will look like this:

    <!-- The DOM --> */
<HTML>
    <body>
        <h1>
            THE TITLE OF THE WEBPAGE
        </h1>
        <div id="container">
            <div class = "content">
            This is the glorious text-content;
            </div>
            </div>
    </body>
    /* keep in mind that the javascript does not alter your html, but the D M - your HTML file will
    look the same, but the javascript changes what the browswer renders

    if you are including your javascript at the top of your file, many of these DOM manipulatio
    methods will not work because the js code is being run before the nodes are created
    in the DOM. the simplest solution is to include your javascript at the bottom of the HTML file
    so that it gets run after the DOM nodes are parsed and created.

    alternatively you can link the javascript file in the <head> of your html document.
    use the <script> tag with the src attribute containing the path to the js file
    and include the defer keyword to load the file after the HTML is parsed, as such: */

    <head>
        <script src="js-file.js" defer></script>
    </head>
</HTML>

    /* read the second bulleit point in this MDN article 
    https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML#applying_css_and_javascript_to_html
    for more information which includes a link to addition script loading strategies.*/



/* EVENTS */

     /* MANIPULATING THE DOM USING JAVASCRIPT ON DEMAND / DYNAMICALLY

     3 ways to make actions occur on webpage

     1. attach functions attributes onto HTML elements
     2. set the 'on_event_' property on the DOM object in your JavaScript
     3. attach event listeners to the nodes in your javascript

     METHOD 1. */

     <button onclick="alert('Hello World')">Click Me</button>

     /* less than ideal. cluttering HTML with javascript. Only have 1 onclick event per element

     METHOD 2

    <!-- html file --> */

     <button id="btn">Click Me</button>
    
     /* javascript file */

     const btn = document.querySelector('#btn');
     btn.onclick = () => alert("Hello World");

     /* this is a little better. DOM element can still only have
        one onclick event.

        need to review arrow functions?
        https://javascript.info/arrow-functions-basics


    METHOD 3

    <!-- the HTML file --> */
<button id="btn">Click Me Too</button>

    /* the JavaScript file */

const btn = document.querySelector('#btn');
btn.addEventListener('click', () => {
  alert("Hello World");
});

/* now script and html are seperate. 
we can also have multiple event listeners if the need arises.
all 3 methods can be used with named functions like so: 



<!-- the HTML file --> */

<button onclick="'alertFunction()">CLICK ME BABY</button>

/* the javascript file

Method 1 */

function alertFunction() {
    alert("YAY! YOU DID IT!");
}

/* Method 2 */

btn.onclick = alertFunction;

/* Method 3 */

btn.addEventListener('click', alertFunction);



/* with all three methods we can access more information about this event 
by passing a parameter to the function */

btn.addEventListener('click', function (e){
    console.log(e);
});
    /* note that function(e) is a callback from addEventListener.
    https://dev.to/i3uckwheat/understanding-callbacks-2o9e

    
    the e in that function is object referencing the event itself.
    gives access to properties like; which mouse button, or key,
    of info about event target - the DOM node that was clicked.
    
    try this */

    btn.addEventListener('click', function (e){
        console.log(e.target);
    });

    /* and this */

    btn.addEventListener('click', function (e){
        e.target.style.background = 'blue';
    });



/* some personal thoughts about callbacks and => functions;

An arrow function is the same as using a callback.
        a callback is a function that has been passed into the parameters of another function.
        There are a few rules to remember but the gist of it is:
        Callback are functions that are "calling" another function in it's aruguments / parameters
        that are then calling back to the original function that called them
        with the results.

        you call a function() that calls another function => that does some work
        and calls back the first function and gives them the results. 

        to add to this confusion, you don't really need to use the =>.

        it's just another sticky weird kinda thing that makes code easier
        or so im told.

        The benefit of doing this is that when you want a function to operate inside of another function
        you can name that function, within the parameters of another function without "calling" it.
        
        This is really stupidly hard to explain because of the word call and it's use with the word function. 
        example:

        function1 is called when it uses the () after it's name. 

        function1( item, function2 );

        if we were to call funciton2 inside the parameters
        
        function1( item, function2() );

        it would probably break function1 and result in something being 'undefined'.
        regardless, this is where it gets confusing because even though we
        aren't technically 'calling' function2, function2 has parameters within
        it that are unseen when we call function1 and those parameters are being 'called back'
        by function2 behind the scene. function1 is being called into action. function1 is then
        calling function2 which is 'calling back' whatever result it produces.

        as far as the => is concerned it basically is a way to create a function easier and often
        without having to declare the function elswhere. This:

        function ihfioh(1, function(item)){
            console.log(item + 7)
        };

        looks like this:

        ihfioh(1, item => console.log(item + 7));
        */

        


